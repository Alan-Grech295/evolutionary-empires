#pragma kernel CSMain
#pragma kernel Initialize

RWTexture3D<float> DensityTexture;
RWStructuredBuffer<float3> Vertices;
RWStructuredBuffer<int> Indices;
int size;
float surfaceLevel;

#include "Includes/MarchTable.compute"
#include "Includes/HashTable.compute"

// TODO: Calculate normals
float3 createVertex(float4 a, float4 b)
{
    float t = (surfaceLevel - a.w) / (b.w - a.w);
    return a.xyz + t * (b.xyz - a.xyz);
}

// Modified hash table insert to increment the vertex buffer counter as soon as it is being inserted
uint HashInsertVert(uint key)
{
    uint slot = hash(key);
    while (true)
    {
        uint prev;
        InterlockedCompareExchange(b_hash[slot].x, EMPTY, key, prev);
        if (prev == EMPTY || prev == key)
        {
            uint val = Vertices.IncrementCounter();
            b_hash[slot].y = val;
            return val;
        }
        slot = (slot + 1) & (e_hashBufferSize - 1);
    }
    
    return 0;
}

int AddVertex(uint3 id, int edgeIndex, float4 cubeCorners[8])
{
    uint key = (id.x + id.y * size + id.z * size * size) * (edgeIndex + 1);
    uint index = HashLookup(key);
    if(index != EMPTY)
        return index;
    
    index = HashInsertVert(key);
    
    /*index = Vertices.IncrementCounter();
    HashInsert(b_hash, key, index, e_hashBufferSize);*/
    
    float4 a = cubeCorners[cornerIndexAFromEdge[edgeIndex]];
    float4 b = cubeCorners[cornerIndexBFromEdge[edgeIndex]];
    
    Vertices[index] = createVertex(a, b);
    return index;
}

[numthreads(8, 8, 8)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    if (id.x > size || id.y > size || id.z > size)
    {
        return;
    }
    
    int3 coord = id;
    
    float4 cubeCorners[8] =
    {
        // Bottom 4 corners
        float4(coord.xyz, DensityTexture[id]),
        float4(coord.xyz + uint3(0, 0, 1), DensityTexture[id + uint3(0, 0, 1)]),
        float4(coord.xyz + uint3(1, 0, 1), DensityTexture[id + uint3(1, 0, 1)]),
        float4(coord.xyz + uint3(1, 0, 0), DensityTexture[id + uint3(1, 0, 0)]),
        
        // Top 4 corners
        float4(coord.xyz + uint3(0, 1, 0), DensityTexture[id + uint3(0, 1, 0)]),
        float4(coord.xyz + uint3(0, 1, 1), DensityTexture[id + uint3(0, 1, 1)]),
        float4(coord.xyz + uint3(1, 1, 1), DensityTexture[id + uint3(1, 1, 1)]),
        float4(coord.xyz + uint3(1, 1, 0), DensityTexture[id + uint3(1, 1, 0)]),
    };
    
    // Calculating the index of the cube
    int cubeIndex = 0;
    if (cubeCorners[0].w > surfaceLevel)
        cubeIndex |= 1;
    if (cubeCorners[1].w > surfaceLevel)
        cubeIndex |= 2;
    if (cubeCorners[2].w > surfaceLevel)
        cubeIndex |= 4;
    if (cubeCorners[3].w > surfaceLevel)
        cubeIndex |= 8;
    if (cubeCorners[4].w > surfaceLevel)
        cubeIndex |= 16;
    if (cubeCorners[5].w > surfaceLevel)
        cubeIndex |= 32;
    if (cubeCorners[6].w > surfaceLevel)
        cubeIndex |= 64;
    if (cubeCorners[7].w > surfaceLevel)
        cubeIndex |= 128;
    
    // The cube is empty
    if (cubeIndex == 0 || cubeIndex == 255)
        return;
    
    int edgeIndices[] = triangulation[cubeIndex];
    
    for (int i = 0; edgeIndices[i] != -1; i += 3)
    {        
        int triIndex = Indices.IncrementCounter();
        
        Indices[triIndex * 3] = AddVertex(id, edgeIndices[i], cubeCorners);
        Indices[triIndex * 3 + 1] = AddVertex(id, edgeIndices[i + 1], cubeCorners);
        Indices[triIndex * 3 + 2] = AddVertex(id, edgeIndices[i + 2], cubeCorners);
    }
}