#pragma kernel CreateVerts
#pragma kernel Initialize
#pragma kernel Finalize

RWTexture3D<float> DensityTexture;
RWStructuredBuffer<float3> Vertices;
RWStructuredBuffer<float3> Normals;
RWStructuredBuffer<int> Indices;
int2 EdgeHashCorrections[12];
int size;
float surfaceLevel;

// Used in the finalization
int numTris;

AppendStructuredBuffer<float> Debug;

static const bool isLocalEdge[8][12] =
{
    { true,     false, false,  true,  false,  false,  false,  false,  true,  false,  false,  false },
    { true,     false, true,   true,  false,  false,  false,  false,  true,  false,  false,  true },
    { true,     false, false,  true,  true,   false,  false,  true,   true,  false,  false,  false },
    { true,     false, true,   true,  true,   false,  true,   true,   true,  false,  false,  true },
    { true,     true,  false,  true,  false,  false,  false,  false,  true,  true,   false,  false },
    { true,     true,  true,   true,  false,  false,  false,  false,  true,  true,   true,   true },
    { true,     true,  false,  true,  true,   true,   false,  true,   true,  true,   false,  false },
    { true,     true,  true,   true,  true,   true,   true,   true,   true,  true,   true,   true }
};

#include "Includes/MarchTable.compute"
#include "Includes/HashTable.compute"

// Taken from Sebastian Lague https://github.com/SebLague/Terraforming/blob/main/Assets/Marching%20Cubes/Scripts/Compute/MarchingCubes.compute
float3 calculateNormal(int3 coord)
{
    int3 offsetX = int3(1, 0, 0);
    int3 offsetY = int3(0, 1, 0);
    int3 offsetZ = int3(0, 0, 1);

    float dx = DensityTexture[coord + offsetX] - DensityTexture[coord - offsetX];
    float dy = DensityTexture[coord + offsetY] - DensityTexture[coord - offsetY];
    float dz = DensityTexture[coord + offsetZ] - DensityTexture[coord - offsetZ];

    return normalize(float3(dx, dy, dz));
}

// TODO: Calculate normals
void AddVertex(float4 a, float4 b, int index)
{
    float t = (surfaceLevel - a.w) / (b.w - a.w);
    float3 vert = a.xyz + t * (b.xyz - a.xyz);
    
    float3 normalA = -calculateNormal(a.xyz);
    float3 normalB = -calculateNormal(b.xyz);
    float3 normal = normalize(normalA + t * (normalB - normalA));
    
    Vertices[index] = vert;
    Normals[index] = normal;
}

// Modified hash table insert to increment the vertex buffer counter as soon as it is being inserted
uint HashInsertVert(uint key)
{
    uint slot = hash(key);
    while (true)
    {
        uint prev;
        InterlockedCompareExchange(b_hash[slot].x, EMPTY, key, prev);
        if (prev == EMPTY || prev == key)
        {
            uint val = Vertices.IncrementCounter();
            b_hash[slot].y = val;
            return val;
        }
        slot = (slot + 1) & (e_hashBufferSize - 1);
    }
    
    return 0;
}

int AddVertex(uint3 id, int edgeIndex, float4 cubeCorners[8])
{
    int2 edgeCorrection = EdgeHashCorrections[edgeIndex];
    uint3 inflatedID = id + 1;
    uint key = (inflatedID.x + inflatedID.y * (size + 2) + inflatedID.z * (size + 2) * (size + 2) + edgeCorrection.x) * 3 + edgeCorrection.y;
    
    if (!(edgeIndex == 0 || edgeIndex == 3 || edgeIndex == 8))
    {
        uint check = 0;
        if (id.x == size - 1)
            check |= 1;
        if (id.y == size - 1)
            check |= 2;
        if (id.z == size - 1)
            check |= 4;
        if (!isLocalEdge[check][edgeIndex])
            return key;
    }
    
    uint index = HashInsertVert(key);
    
    float4 a = cubeCorners[cornerIndexAFromEdge[edgeIndex]];
    float4 b = cubeCorners[cornerIndexBFromEdge[edgeIndex]];
    
    AddVertex(a, b, index);
    
    return key;
}

[numthreads(512, 1, 1)]
void Finalize(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numTris)
        return;
    
    Indices[id.x] = HashLookup(Indices[id.x]);
}

[numthreads(8, 8, 8)]
void CreateVerts(uint3 id : SV_DispatchThreadID)
{
    if (id.x > size || id.y > size || id.z > size)
    {
        return;
    }
    
    int3 coord = id + 1;
    
    float4 cubeCorners[8] =
    {
        // Bottom 4 corners
        float4(coord.xyz, DensityTexture[id + 1]),
        float4(coord.xyz + uint3(0, 0, 1), DensityTexture[id + 1 + uint3(0, 0, 1)]),
        float4(coord.xyz + uint3(1, 0, 1), DensityTexture[id + 1 + uint3(1, 0, 1)]),
        float4(coord.xyz + uint3(1, 0, 0), DensityTexture[id + 1 + uint3(1, 0, 0)]),
        
        // Top 4 corners
        float4(coord.xyz + uint3(0, 1, 0), DensityTexture[id + 1 + uint3(0, 1, 0)]),
        float4(coord.xyz + uint3(0, 1, 1), DensityTexture[id + 1 + uint3(0, 1, 1)]),
        float4(coord.xyz + uint3(1, 1, 1), DensityTexture[id + 1 + uint3(1, 1, 1)]),
        float4(coord.xyz + uint3(1, 1, 0), DensityTexture[id + 1 + uint3(1, 1, 0)]),
    };
    
    // Calculating the index of the cube
    int cubeIndex = 0;
    if (cubeCorners[0].w > surfaceLevel)
        cubeIndex |= 1;
    if (cubeCorners[1].w > surfaceLevel)
        cubeIndex |= 2;
    if (cubeCorners[2].w > surfaceLevel)
        cubeIndex |= 4;
    if (cubeCorners[3].w > surfaceLevel)
        cubeIndex |= 8;
    if (cubeCorners[4].w > surfaceLevel)
        cubeIndex |= 16;
    if (cubeCorners[5].w > surfaceLevel)
        cubeIndex |= 32;
    if (cubeCorners[6].w > surfaceLevel)
        cubeIndex |= 64;
    if (cubeCorners[7].w > surfaceLevel)
        cubeIndex |= 128;
    
    // The cube is empty
    if (cubeIndex == 0 || cubeIndex == 255)
        return;
    
    int edgeIndices[] = triangulation[cubeIndex];
    
    for (int i = 0; edgeIndices[i] != -1; i += 3)
    {        
        int triIndex = Indices.IncrementCounter();
        
        Indices[triIndex * 3 + 2]       = AddVertex(id, edgeIndices[i], cubeCorners);
        Indices[triIndex * 3 + 1]   = AddVertex(id, edgeIndices[i + 1], cubeCorners);
        Indices[triIndex * 3]   = AddVertex(id, edgeIndices[i + 2], cubeCorners);
    }
}